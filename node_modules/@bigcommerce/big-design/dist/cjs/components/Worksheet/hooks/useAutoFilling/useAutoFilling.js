"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAutoFilling = void 0;
var _react = require("react");
var _useUpdateItems = require("../useUpdateItems");
var _useWorksheetStore = require("../useWorksheetStore");
const useAutoFilling = cell => {
  const {
    store,
    useStore
  } = (0, _useWorksheetStore.useWorksheetStore)();
  const {
    updateItems
  } = (0, _useUpdateItems.useUpdateItems)();
  const selectedCells = useStore(store, state => state.selectedCells);
  const disabledRows = useStore(store, state => state.disabledRows);
  const rows = useStore(store, (0, _react.useMemo)(() => state => state.rows, []));
  const isBlockedFillOut = useStore(store, (0, _react.useMemo)(() => state => state.isBlockedFillOut, []));
  const isSelectingActive = useStore(store, (0, _react.useMemo)(() => state => state.isSelectingActive, []));
  const isAutoFillActive = useStore(store, (0, _react.useMemo)(() => state => state.isAutoFillActive, []));
  const setSelectingActive = useStore(store, (0, _react.useMemo)(() => state => state.setSelectingActive, []));
  const setAutoFillActive = useStore(store, (0, _react.useMemo)(() => state => state.setAutoFillActive, []));
  const setBlockFillOut = useStore(store, (0, _react.useMemo)(() => state => state.setBlockFillOut, []));
  const setSelectedCells = useStore(store, state => state.setSelectedCells);
  const onFillFullColumn = (0, _react.useCallback)(() => {
    const cells = rows.reduce((accum, row, idx) => idx > cell.rowIndex && !disabledRows.includes(idx + 1) ? [...accum, {
      ...cell,
      rowIndex: idx,
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      value: row[cell.hash]
    }] : accum, []);
    updateItems(cells, cells.map(() => cell.value));
  }, [cell, disabledRows, rows, updateItems]);
  const handleSelectedCells = (0, _react.useCallback)(() => {
    const copySelectedCells = [...selectedCells];
    if (isAutoFillActive || isSelectingActive) {
      const isUnic = !copySelectedCells.some(editedCell => editedCell.rowIndex === cell.rowIndex);
      const firstSelectedCell = copySelectedCells[0];
      if (firstSelectedCell && firstSelectedCell.rowIndex <= cell.rowIndex && isUnic) {
        const {
          columnIndex,
          hash,
          type
        } = firstSelectedCell;
        copySelectedCells.push({
          ...cell,
          columnIndex,
          hash,
          type,
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          value: rows[cell.rowIndex][firstSelectedCell.hash]
        });
      }
      if (copySelectedCells.length > 1 && cell.rowIndex === copySelectedCells[copySelectedCells.length - 2].rowIndex) {
        copySelectedCells.pop();
      }
      setSelectedCells(copySelectedCells);
    }
  }, [cell, isAutoFillActive, isSelectingActive, rows, selectedCells, setSelectedCells]);
  (0, _react.useEffect)(() => {
    if (!isBlockedFillOut && !isAutoFillActive && selectedCells.length > 1) {
      const availableCells = selectedCells.filter(_ref => {
        let {
          rowIndex
        } = _ref;
        return !disabledRows.includes(rowIndex + 1);
      });
      updateItems(availableCells,
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      availableCells.map(_ref2 => {
        let {
          hash
        } = _ref2;
        return rows[selectedCells[0].rowIndex][hash];
      }));
    }
  }, [disabledRows, isAutoFillActive, isBlockedFillOut, isSelectingActive, rows, selectedCells, setSelectingActive, updateItems]);
  return {
    isAutoFillActive,
    onFillFullColumn,
    setIsMouseDown: setAutoFillActive,
    setSelectingActive,
    setBlockFillOut,
    setSelectedCell: handleSelectedCells
  };
};
exports.useAutoFilling = useAutoFilling;