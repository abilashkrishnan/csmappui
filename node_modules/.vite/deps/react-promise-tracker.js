import {
  require_react
} from "./chunk-NVDSUZN5.js";
import {
  __toESM
} from "./chunk-ZC22LKFR.js";

// node_modules/react-promise-tracker/es/tinyEmmiter.js
var Emitter = class {
  emit(event, ...args) {
    if (!event)
      return this;
    for (const fn of this._e(event)) {
      fn.apply(fn.ctx, [...args]);
      if (fn.off_event == true)
        this.off(event, fn);
    }
    return this;
  }
  on(event, fn, ctx) {
    if (!event)
      return this;
    fn.ctx = ctx;
    this._e(event).push(fn);
    return this;
  }
  once(event, fn, ctx) {
    if (!event)
      return this;
    fn.ctx = ctx;
    fn.off_event = true;
    return this.on(event, fn);
  }
  off(event, fn) {
    if (!event)
      return this;
    if (!this[event])
      return this;
    const e = this._e(event);
    if (!fn) {
      delete this[event];
      return this;
    }
    this[event] = e.filter((f) => f != fn);
    return this;
  }
  _e(e) {
    return this[e] || (this[e] = []);
  }
};

// node_modules/react-promise-tracker/es/constants.js
var defaultArea = "default-area";

// node_modules/react-promise-tracker/es/trackPromise.js
var emitter = new Emitter();
var promiseCounterUpdateEventId = "promise-counter-update";
var counter = {
  [defaultArea]: 0
};
var getCounter = (area) => counter[area];
var trackPromise = (promise, area) => {
  area = area || defaultArea;
  incrementPromiseCounter(area);
  const onResolveHandler = () => decrementPromiseCounter(area);
  promise.then(onResolveHandler, onResolveHandler);
  return promise;
};
var incrementPromiseCounter = (area) => {
  incrementCounter(area);
  const promiseInProgress = anyPromiseInProgress(area);
  emitter.emit(promiseCounterUpdateEventId, promiseInProgress, area);
};
var incrementCounter = (area) => {
  if (Boolean(counter[area])) {
    counter[area]++;
  } else {
    counter[area] = 1;
  }
};
var anyPromiseInProgress = (area) => counter[area] > 0;
var decrementPromiseCounter = (area) => {
  counter[area] > 0 && decrementCounter(area);
  const promiseInProgress = anyPromiseInProgress(area);
  emitter.emit(promiseCounterUpdateEventId, promiseInProgress, area);
};
var decrementCounter = (area) => {
  counter[area]--;
};
var manuallyResetPromiseCounter = (area) => {
  area = area || defaultArea;
  counter[area] = 0;
  emitter.emit(promiseCounterUpdateEventId, false, area);
};
var manuallyDecrementPromiseCounter = (area) => {
  area = area || defaultArea;
  decrementPromiseCounter(area);
};
var manuallyIncrementPromiseCounter = (area) => {
  area = area || defaultArea;
  incrementPromiseCounter(area);
};

// node_modules/react-promise-tracker/es/trackerHoc.js
var import_react = __toESM(require_react());

// node_modules/react-promise-tracker/es/setupConfig.js
var defaultConfig = {
  area: defaultArea,
  delay: 0
};
var setupConfig = (outerConfig) => ({
  area: !outerConfig || !outerConfig.area ? defaultArea : outerConfig.area,
  delay: !outerConfig || !outerConfig.delay ? 0 : outerConfig.delay
});

// node_modules/react-promise-tracker/es/trackerHoc.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var promiseTrackerHoc = (ComponentToWrap) => {
  return class promiseTrackerComponent extends import_react.Component {
    constructor(props) {
      super(props);
      this.state = {
        promiseInProgress: false,
        internalPromiseInProgress: false,
        config: setupConfig(props.config)
      };
      this.notifyPromiseInProgress = this.notifyPromiseInProgress.bind(this);
      this.updateProgress = this.updateProgress.bind(this);
      this.subscribeToCounterUpdate = this.subscribeToCounterUpdate.bind(this);
    }
    notifyPromiseInProgress() {
      this.state.config.delay === 0 ? this.setState({
        promiseInProgress: true
      }) : setTimeout(() => {
        const progress = Boolean(getCounter(this.state.config.area) > 0);
        this.setState({
          promiseInProgress: progress
        });
      }, this.state.config.delay);
    }
    updateProgress(progress, afterUpdateCallback) {
      this.setState({
        internalPromiseInProgress: progress
      }, afterUpdateCallback);
      !progress ? this.setState({
        promiseInProgress: false
      }) : this.notifyPromiseInProgress();
    }
    subscribeToCounterUpdate() {
      emitter.on(promiseCounterUpdateEventId, (anyPromiseInProgress2, area) => {
        if (this.state.config.area === area) {
          this.updateProgress(anyPromiseInProgress2);
        }
      });
    }
    componentDidMount() {
      this.updateProgress(Boolean(getCounter(this.state.config.area) > 0), this.subscribeToCounterUpdate);
    }
    componentWillUnmount() {
      emitter.off(promiseCounterUpdateEventId);
    }
    render() {
      return import_react.default.createElement(ComponentToWrap, _extends({}, this.props, {
        config: this.state.config,
        promiseInProgress: this.state.promiseInProgress
      }));
    }
  };
};

// node_modules/react-promise-tracker/es/trackerHook.js
var import_react2 = __toESM(require_react());
var usePromiseTracker = (outerConfig = defaultConfig) => {
  let isMounted = import_react2.default.useRef(false);
  import_react2.default.useEffect(() => {
    isMounted.current = true;
    return () => isMounted.current = false;
  }, []);
  const [config] = import_react2.default.useState(setupConfig(outerConfig));
  import_react2.default.useEffect(() => {
    if (isMounted.current && config && config.area && getCounter(config.area) > 0) {
      setInternalPromiseInProgress(true);
      setPromiseInProgress(true);
    }
  }, [config]);
  const [internalPromiseInProgress, setInternalPromiseInProgress] = import_react2.default.useState(false);
  const [promiseInProgress, setPromiseInProgress] = import_react2.default.useState(false);
  const latestInternalPromiseInProgress = import_react2.default.useRef(internalPromiseInProgress);
  const notifyPromiseInProgress = () => {
    !config || !config.delay || config.delay === 0 ? setPromiseInProgress(true) : setTimeout(() => {
      if (isMounted.current && latestInternalPromiseInProgress.current) {
        setPromiseInProgress(true);
      }
    }, config.delay);
  };
  const updatePromiseTrackerStatus = (anyPromiseInProgress2, areaAffected) => {
    if (isMounted.current && config.area === areaAffected) {
      setInternalPromiseInProgress(anyPromiseInProgress2);
      latestInternalPromiseInProgress.current = anyPromiseInProgress2;
      if (!anyPromiseInProgress2) {
        setPromiseInProgress(false);
      } else {
        notifyPromiseInProgress();
      }
    }
  };
  import_react2.default.useEffect(() => {
    latestInternalPromiseInProgress.current = internalPromiseInProgress;
    emitter.on(promiseCounterUpdateEventId, updatePromiseTrackerStatus);
    return () => emitter.off(promiseCounterUpdateEventId, updatePromiseTrackerStatus);
  }, []);
  return {
    promiseInProgress
  };
};
export {
  manuallyDecrementPromiseCounter,
  manuallyIncrementPromiseCounter,
  manuallyResetPromiseCounter,
  promiseTrackerHoc,
  trackPromise,
  usePromiseTracker
};
//# sourceMappingURL=react-promise-tracker.js.map
