{
  "version": 3,
  "sources": ["../../react-promise-tracker/es/tinyEmmiter.js", "../../react-promise-tracker/es/constants.js", "../../react-promise-tracker/es/trackPromise.js", "../../react-promise-tracker/es/trackerHoc.js", "../../react-promise-tracker/es/setupConfig.js", "../../react-promise-tracker/es/trackerHook.js"],
  "sourcesContent": ["// Based on:\n// https://github.com/scottcorgan/tiny-emitter\n// class based\nexport class Emitter {\n  emit(event, ...args) {\n    if (!event) return this;\n    for (const fn of this._e(event)) {\n      fn.apply(fn.ctx, [...args]);\n      if (fn.off_event == true) this.off(event, fn);\n    }\n    return this;\n  }\n  on(event, fn, ctx) {\n    if (!event) return this;\n    fn.ctx = ctx;\n    this._e(event).push(fn);\n    return this;\n  }\n  once(event, fn, ctx) {\n    if (!event) return this;\n    fn.ctx = ctx;\n    fn.off_event = true;\n    return this.on(event, fn);\n  }\n  off(event, fn) {\n    if (!event) return this;\n    if (!this[event]) return this;\n    const e = this._e(event);\n    if (!fn) {\n      delete this[event];\n      return this;\n    }\n    this[event] = e.filter(f => f != fn);\n    return this;\n  }\n  _e(e) {\n    return this[e] || (this[e] = []);\n  }\n}", "export const defaultArea = 'default-area';", "import { Emitter } from \"./tinyEmmiter\";\nimport { defaultArea } from \"./constants\";\nexport const emitter = new Emitter();\nexport const promiseCounterUpdateEventId = \"promise-counter-update\";\nlet counter = {\n  [defaultArea]: 0\n};\nexport const getCounter = area => counter[area];\nexport const trackPromise = (promise, area) => {\n  area = area || defaultArea;\n  incrementPromiseCounter(area);\n  const onResolveHandler = () => decrementPromiseCounter(area);\n  promise.then(onResolveHandler, onResolveHandler);\n  return promise;\n};\nconst incrementPromiseCounter = area => {\n  incrementCounter(area);\n  const promiseInProgress = anyPromiseInProgress(area);\n  emitter.emit(promiseCounterUpdateEventId, promiseInProgress, area);\n};\nconst incrementCounter = area => {\n  if (Boolean(counter[area])) {\n    counter[area]++;\n  } else {\n    counter[area] = 1;\n  }\n};\nconst anyPromiseInProgress = area => counter[area] > 0;\nconst decrementPromiseCounter = area => {\n  counter[area] > 0 && decrementCounter(area);\n  const promiseInProgress = anyPromiseInProgress(area);\n  emitter.emit(promiseCounterUpdateEventId, promiseInProgress, area);\n};\nconst decrementCounter = area => {\n  counter[area]--;\n};\nexport const manuallyResetPromiseCounter = area => {\n  area = area || defaultArea;\n  counter[area] = 0;\n  emitter.emit(promiseCounterUpdateEventId, false, area);\n};\nexport const manuallyDecrementPromiseCounter = area => {\n  area = area || defaultArea;\n  decrementPromiseCounter(area);\n};\nexport const manuallyIncrementPromiseCounter = area => {\n  area = area || defaultArea;\n  incrementPromiseCounter(area);\n};\n// TODO: Enhancement we could catch here errors and throw an Event in case there's an HTTP Error\n// then the consumer of this event can be listening and decide what to to in case of error", "function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nimport React, { Component } from 'react';\nimport { emitter, getCounter, promiseCounterUpdateEventId } from './trackPromise';\nimport { setupConfig } from './setupConfig';\n\n// Props:\n// config: {\n//  area:  // can be null|undefined|'' (will default to DefaultArea) or area name\n//  delay: // Wait Xms to display the spinner (fast connections scenario avoid blinking)\n//            default value 0ms\n// }\nexport const promiseTrackerHoc = ComponentToWrap => {\n  return class promiseTrackerComponent extends Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        promiseInProgress: false,\n        internalPromiseInProgress: false,\n        config: setupConfig(props.config)\n      };\n      this.notifyPromiseInProgress = this.notifyPromiseInProgress.bind(this);\n      this.updateProgress = this.updateProgress.bind(this);\n      this.subscribeToCounterUpdate = this.subscribeToCounterUpdate.bind(this);\n    }\n    notifyPromiseInProgress() {\n      this.state.config.delay === 0 ? this.setState({\n        promiseInProgress: true\n      }) : setTimeout(() => {\n        const progress = Boolean(getCounter(this.state.config.area) > 0);\n        this.setState({\n          promiseInProgress: progress\n        });\n      }, this.state.config.delay);\n    }\n    updateProgress(progress, afterUpdateCallback) {\n      this.setState({\n        internalPromiseInProgress: progress\n      }, afterUpdateCallback);\n      !progress ? this.setState({\n        promiseInProgress: false\n      }) : this.notifyPromiseInProgress();\n    }\n    subscribeToCounterUpdate() {\n      emitter.on(promiseCounterUpdateEventId, (anyPromiseInProgress, area) => {\n        if (this.state.config.area === area) {\n          this.updateProgress(anyPromiseInProgress);\n        }\n      });\n    }\n    componentDidMount() {\n      this.updateProgress(Boolean(getCounter(this.state.config.area) > 0), this.subscribeToCounterUpdate);\n    }\n    componentWillUnmount() {\n      emitter.off(promiseCounterUpdateEventId);\n    }\n    render() {\n      return /*#__PURE__*/React.createElement(ComponentToWrap, _extends({}, this.props, {\n        config: this.state.config,\n        promiseInProgress: this.state.promiseInProgress\n      }));\n    }\n  };\n};", "import { defaultArea } from \"./constants\";\nexport const defaultConfig = {\n  area: defaultArea,\n  delay: 0\n};\n\n// Defensive config setup, fulfill default values\nexport const setupConfig = outerConfig => ({\n  area: !outerConfig || !outerConfig.area ? defaultArea : outerConfig.area,\n  delay: !outerConfig || !outerConfig.delay ? 0 : outerConfig.delay\n});", "import React from \"react\";\nimport { emitter, promiseCounterUpdateEventId, getCounter } from \"./trackPromise\";\nimport { defaultConfig, setupConfig } from \"./setupConfig\";\nexport const usePromiseTracker = (outerConfig = defaultConfig) => {\n  let isMounted = React.useRef(false);\n  React.useEffect(() => {\n    isMounted.current = true;\n    return () => isMounted.current = false;\n  }, []);\n\n  // Included in state, it will be evaluated just the first time,\n  // TODO: discuss if this is a good approach\n  // We need to apply defensive programming, ensure area and delay default to secure data\n  // cover cases like not all params informed, set secure defaults\n  const [config] = React.useState(setupConfig(outerConfig));\n\n  // Edge case, when we start the application if we are loading just onComponentDidMount\n  // data, event emitter could have already emitted the event but subscription is not yet\n  // setup\n  React.useEffect(() => {\n    if (isMounted.current && config && config.area && getCounter(config.area) > 0) {\n      setInternalPromiseInProgress(true);\n      setPromiseInProgress(true);\n    }\n  }, [config]);\n\n  // Internal will hold the current value\n  const [internalPromiseInProgress, setInternalPromiseInProgress] = React.useState(false);\n  // Promise in progress is 'public', it can be affected by the _delay_ parameter\n  // it may not show the current state\n  const [promiseInProgress, setPromiseInProgress] = React.useState(false);\n\n  // We need to hold a ref to latestInternal, to check the real value on\n  // callbacks (if not we would get always the same value)\n  // more info: https://overreacted.io/a-complete-guide-to-useeffect/\n  const latestInternalPromiseInProgress = React.useRef(internalPromiseInProgress);\n  const notifyPromiseInProgress = () => {\n    !config || !config.delay || config.delay === 0 ? setPromiseInProgress(true) : setTimeout(() => {\n      // Check here ref to internalPromiseInProgress\n      if (isMounted.current && latestInternalPromiseInProgress.current) {\n        setPromiseInProgress(true);\n      }\n    }, config.delay);\n  };\n  const updatePromiseTrackerStatus = (anyPromiseInProgress, areaAffected) => {\n    if (isMounted.current && config.area === areaAffected) {\n      setInternalPromiseInProgress(anyPromiseInProgress);\n      // Update the ref object as well, we will check it when we need to\n      // cover the _delay_ case (setTimeout)\n      latestInternalPromiseInProgress.current = anyPromiseInProgress;\n      if (!anyPromiseInProgress) {\n        setPromiseInProgress(false);\n      } else {\n        notifyPromiseInProgress();\n      }\n    }\n  };\n  React.useEffect(() => {\n    latestInternalPromiseInProgress.current = internalPromiseInProgress;\n    emitter.on(promiseCounterUpdateEventId, updatePromiseTrackerStatus);\n    return () => emitter.off(promiseCounterUpdateEventId, updatePromiseTrackerStatus);\n  }, []);\n  return {\n    promiseInProgress\n  };\n};"],
  "mappings": "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",
  "names": ["anyPromiseInProgress", "React", "import_react", "React", "anyPromiseInProgress"]
}
